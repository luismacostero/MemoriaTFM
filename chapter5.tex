\cleardoublepage

\chapter{Optimización de la eficiencia energética de OmpSs sobre arquitecturas asimétricas}
\label{ch:chapter5}

\section{Descripción de la estrategia de optimización}

\subsection{DVFS sobre la arquitectura big.LITTLE}

\subsection{Evaluación de rendimiento/eficiencia energética de las tareas}


\section{Políticas de reducción de consumo}

\subsection{P1}
%%
\comentario{Reescribir}%%
Durante la ejecución de un programa paralelo mediante un paradigma basado
en tareas, puede ocurrir el caso en el que la mayor parte de tareas listas
para ser ejecutadas sean críticas, provocando que no existan más tareas
listas hasta que estas acaben. Un ejemplo de aplicación con este
comportamiento sería aquella cuyo árbol de dependencias se encogiera muy
rápidamente en algún punto intermedio de la ejecución, para luego volverse
a expandir rápidamente (un árbol con forma de diábolo). En este árbol, las
tareas del cuello de botella del medio serían tareas críticas ya que son
prioritarias para que la ejecución continúe su ejecución, y además, en el
momento que esto ocurra, un gran número de tareas estarán listas para ser
ejecutadas y
poder continuar la ejecución del problema.\\
Este problema aplicado al planificador botlev supondría que en el momento
en el que el árbol se estreche, la cola de tareas no críticas tendría un
tamaño mucho inferior al de tareas críticas, y por tanto los cores LITTLE
tendrían mucha menor carga de trabajo que los cores big. Esto ocurriría
mientras que los cores big finalicen la ejecución de sus tareas críticas y
se preparen más tareas para ejecutar por los cores LITTLE.\\
Aunque una forma de intentar paliar este problema sería obligar a que los
cores lentos ejecutaran tareas críticas, esto podría provocar que se
retrase la finalización de una tarea crítica, ya que aunque su ejecución
puede comenzar antes (pues se disponen de más cores para distribuir el
mismo número de tareas), el rendimiento de los cores LITTLE es mucho
inferior que el de los cores big, provocando retrasos en la ejecución,
incluso llegando a aumentar el problema del cuello de botella.

La política P1 intenta reducir este problema desde un enfoque distinto. La
idea principal que se encuentra detrás de esta política es la de aprovechar
estos momentos en los que la carga de trabajo sobre los cores lentos es
menor para intentar disminuir el consumo energético aplicando una reducción
de frecuencia sobre el cluster LITTLE. Como se podía ver en la
figura~\todo{ref}, reducir la frecuencia al cluster LITTLE implica que la
potencia instantánea disminuye. Es cierto que al reducir la frecuencia de
los cores el tiempo usado en ejecutar una tarea aumenta, pero como esta
técnica únicamente se aplica en los momentos en los que la ejecución está
limitada por el gran número de tareas críticas y el bajo número de tareas
no críticas, se espera que el impacto final en el rendimiento no sea muy
elevado.\\
La forma de aplicar esta política sobre botlev consiste en monitorizar
constantemente el número de tareas tanto críticas como no críticas listas
para ser ejecutadas (reflejado en el tamaño de las colas internas del
planificador), y actuar en función a la relación entre el tamaño de ambas
colas. La figura~\ref{s5:fig:listing-p1} muestra un fragmento esquemático
del código encargado de realizar esta tarea. Este método es invocado cada
vez que el tamaño de una cola cambia (ya sea porque una tarea comienza su
ejecución, o porque una tarea se encuentra lista para ser ejecutada y es
introducida en una cola). Como se puede ver en la
línea~\ref{s5:lst:p1-calculoPrincipal(a)}, la frecuencia a la que cambiar
el cluster se calcula como una proporción directa entre el tamaño de ambas
colas, así, si el número de tareas críticas es el doble que el de las
tareas no críticas, la frecuencia se disminuye un escalón; si el tamaño es
el triple, la frecuencia se disminuye hasta el tercer escalón de
frecuencia, etc. Recordar que los valores de frecuencia que puede tomar el
cluster están limitados por el kernel del sistema operativo, como se
mencionó en la sección~\todo{ref}. La
línea~\ref{s5:lst:p1-calculoPrincipal(b)} asegura que la frecuencia final
no es menor que la menor frecuencia soportada. Destacar que de esta manera
se consigue que el cambio de frecuencia en el cluster se realice de manera
escalonada según varía el tamaño de las colas.\\
%%%
\comentario{La línea 8 es un poco desconcertante}
%%%
\begin{figure}
  \centering

  \begin{lstlisting}[language=C++]
int P1(int bigQueueSize, int littleQueueSize){
  int nxtFreq;
      
  if( littleQueueSize==0 ) nxtFreq = FreqCfg::minLittleFreq; |\label{s5:lst:p1-casoEsp1}|
  else if( bigQueueSize==0 ) nxtFreq = FreqCfg::maxLittleFreq; |\label{s5:lst:p1-casoEsp2}|
  else{
    int idx = min((bigQueueSize / littleQueueSize), |\label{s5:lst:p1-calculoPrincipal(a)}|
                   FreqCfg::maxIdxLittle );         |\label{s5:lst:p1-calculoPrincipal(b)}|
    nxtFreq = FreqCfg::littleFreqs[idx];
  }
  return changeLittleFreq(nxtFreq);
}
\end{lstlisting}

  \caption[Fragmento de código esquemático para la política P1]
  {Fragmento de código esquemático para la política P1.}
  \label{s5:fig:listing-p1}
\end{figure}

Adicionalmente al comportamiento general de esta política, hay que
distinguir dos casos especiales que merecen ser mencionados: el caso en el
que no exista ninguna tarea crítica lista para ser ejecutada, y el caso
opuesto en el que todas las tareas listas sean críticas y los cores lentos
estén totalmente ociosos. En estos casos, las
líneas~\ref{s5:lst:p1-casoEsp1}-\ref{s5:lst:p1-casoEsp2} se encargan de
aumentar la frecuencia al máximo directamente en caso de que todas las
tareas sean no críticas, o de disminuir la frecuencia al mínimo en caso de
que no exista ninguna tarea no crítica que ejecutar.

\todo{quizás poner aquí la evolución de la frecuencia en funcińo del tamaño
  de las colas. Puede que mejor en la sección de resultados}.

\subsection{P2 y P2'}
A la hora de aplicar técnicas de escalado de frecuencia (DVFS) sobre una
arquitectura o problema, la técnica presenta de manera simplificada dos
grandes dimensiones sobre las que tomar decisiones sobre los parámetros de
configuración para conseguir el objetivo de reducir el consumo total:
(a)~una primera dimensión que determina qué frecuencias utilizar durante
los diferentes cambios, y (b)~una segunda dimensión que determina en qué
momentos de la ejecución se debe modificar la frecuencia.\\
La primera dimensión normalmente viene acotada por la propia arquitectura
sobre la que se ejecuta el problema, ya que es común que el procesador no
pueda funcionar a cualquier frecuencia, sino solamente a una serie de
frecuencias prefijadas de antemano. Esto hace que tomar la decisión de a
qué frecuencia se desea cambiar el procesador sea únicamente realizar una
elección en un conjunto cerrado y finito de frecuencias. Destacar que en
ocasiones puede ser interesante descartar algunas de estas frecuencias y no
tenerlas en consideración, ya sea porque impactan de manera muy negativa en
el rendimiento, o no tienen un impacto muy significativo en la mejora de
consumo.\\
La segunda dimensión está estrechamente relacionada con el problema a
ejecutar y el conocimiento que se tenga de él. Las decisiones que se pueden
tomar van desde decisiones de grano grueso, como puede ser tener en cuenta
el nivel de carga de trabajo de cada procesador y variar la frecuencia en
función de este dato, hasta decisiones de grano más fino como puede ser
conocer el comportamiento de cada una de las tareas a ejecutar y el árbol
de dependencias de antemano, y tomar decisiones en función de estos
parámetros, por ejemplo, si se sabe que una tarea es crítica, aumentar la
frecuencia para así intentar generar nuevas tareas cuanto antes, o si se
sabe que la ejecución va a estar bloqueada hasta que no finalice una tarea
en concreto, disminuir la frecuencia del resto de procesadores hasta que
esta tarea finalice y así intentar disminuir el consumo energético. Hay que
hacer notar que aunque bajar la frecuencia del procesador implique
conseguir una potencia instantánea menor, eso no implica que la energía
final consumida sea también menor, ya que al bajar la frecuencia el tiempo
de ejecución puede aumentar lo suficiente provocando un consumo de energía
mayor al final.\\
Adicionalmente a estas dos dimensiones, los sistemas heterogéneos, y en
concreto las arquitecturas asimétricas, presentan una dimensión extra sobre
la que tomar decisiones: (c) decidir sobre qué elementos de cálculo aplicar
el escalado de frecuencia. En el caso de las arquitecturas asimétricas,
esta decisión se simplifica a decidir si aplicar el escalado al cluster de
cores big, o al cluster de cores LITTLE.\\

La primera intuición que surge al intentar aplicar un escalado de
frecuencia sobre una arquitectura asimétrica es la de pensar que debido a
la gran diferencia de rendimiento entre los cores big y LITTLE (como se
pudo ver en la figura~\todo{ref}), aplicar la técnica a los cores big puede
suponer una pérdida significativa de rendimiento, lo cuál puede provocar
incluso un aumento en el consumo energético al tardar mayor tiempo en
ejecutarse la aplicación, es decir, se podría llegar a empeorar tanto el
rendimiento como el consumo energético. Para evitar que suceda este hecho,
las políticas P2 y P2' han sido diseñadas para modificar la frecuencia
sobre el cluster de cores LITTLE, y así intentar no causar un gran impacto
sobre el rendimiento. Además, las políticas han sido desarrolladas sobre el
planificador botlev comentando en la seccion~\ref{s3:botlev}, con el
objetivo de intentar asegurar que las tareas críticas se ejecutan en los
cores big para así evitar que se retrasen si se ejecutaran en un core
LITTLE con la frecuencia disminuida.\\
Para determina cuando variar la frecuencia del cluster se tienen en cuenta
el número de tareas listas para ser ejecutadas, así, si existen muchas
tareas para ser ejecutadas, la frecuencia será alta para intentar finalizar
la ejecución cuanto antes, mientras que si existen pocas tareas listas para
ser ejecutadas la frecuencia será menor, intentando favorecer el ahorro
energético. Este planteamiento es similar a tener en cuenta la carga de
trabajo del sistema, pero medida en número de tareas pendientes en vez de
ciclos ociosos/ocupados del procesador. Más concretamente, las políticas
monitorizan el tamaño de la cola de tareas listas para ser ejecutadas, y
determinan cuál es el tamaño máximo de la cola hasta el momento de manera
dinámica. Si la cola posee un tamaño igual o superior al tamaño máximo
conocido, significa que el número de tareas es elevado y por tanto la
frecuencia debe ser elevada. Si el tamaño es menor, entonces se determina
en que porcentaje es menor, y en función de las frecuencias consideradas se
toma la decisión de modificar la frecuencia actual o no. En el código de la
figura~\ref{s5:fig:listing-p2} se muestra el pseudocódigo asociado a estas
políticas. El bloque \texttt{if} de la línea~\ref{s5:lst:p2-detectPico} es
el encargado de determinar si el tamaño actual de la cola es mayor o igual
que cualquier tamaño hasta el momento, y en caso de ser así, configurar el
cluster para que funcione a máxima frecuencia. Esto es equivalente a
determinar si hay un pico de carga de trabajo o no. Las
líneas~\ref{s5:lst:p2-tamStep1}-\ref{s5:lst:p2-tamStep2} determinan el
número de tareas que separan una frecuencia de la otra. La forma de
determinar esta cantidad consiste en repartir de manera equitativa el
espacio máximo de tareas conocido hasta el momento entre todas las
frecuencias, y asignar la frecuencia actual en función de qué tamaño posea
la cola (línea~\ref{s5:lst:p2-step}). Por ejemplo, si el cluster es capaz
de ejecutarse a 5 frecuencias distintas, y hasta el momento el número
máximo de tareas preparadas para ser ejecutas ha sido de 20 tareas, antes
de cambiar de frecuencia se dispone de un margen de 4 tareas. Si el tamaño
actual de la cola es de 3 tareas, la frecuencia del cluster será la mínima,
mientras que si es de 5 tareas, la frecuencia ya no será la mínima, sino la
frecuencia inmeditamente superior.

\begin{figure}
  \centering

  \begin{lstlisting}[language=C++]
int P2(int littleQueueSize, int bigQueueSize){      
  //Comprobamos si estamos en un pico de carga
  if(littleQueueSize >= FreqCfg::maxQueueSize){ |\label{s5:lst:p2-detectPico}|
    FreqCfg::maxQueueSize = littleQueueSize;

    return changeLittleFreq(FreqCfg::maxLittleFreq);
  }

  //Tamanyo para cambiar de frecuencia
  float tamStep = (FreqCfg::maxQueueSize*1.0 /     |\label{s5:lst:p2-tamStep1}|
                   (FreqCfg::maxIdxLittle+1)*1.0); |\label{s5:lst:p2-tamStep2}|
  //Escalon actual
  int step = (int) (littleQueueSize / tamStep);    |\label{s5:lst:p2-step}|

  return changeLittleFreq(FreqCfg::littleFreqs[step]);
}
  \end{lstlisting}

  \caption{Pseudocódigo para las políticas P2 y P2'.}

  \label{s5:fig:listing-p2}
\end{figure}

La diferencia entre las políticas P2 y P2' se encuentra en el rango de
frecuencias que se consideran para el cluster. Así, la política P2 divide
el tamaño de la cola entre todas las frecuencias posibles para el
procesador, mientras que la política P2' solamente considera la frecuencia
máxima y mínima del mismo. 


\subsection{P3}
La política P3 es similar a la política anterior, pero realizando el
escalado de frecuencias sobre el cluster de cores big en vez de cores
LITTLE. De manera similar a la anterior, la política ha sido implementada
sobre el planificador botlev implementado sobre \ompss para intentar
minimizar el impacto negativo sobre las tareas críticas. La
figura~\ref{s5:fig:P3-evo} muestra los distintos cambios de frecuencia que
se han realizado en función del número de tareas listas para ser
ejecutadas. En la parte superior, se muestra la evolución del número de
tareas listas para ser ejecutadas según avanza la ejecución del
problema. En la gráfica inferior, se muestra la frecuencia del cluster de
cores big durante la ejecución. Ambas gráficas poseen la misma escala en el
eje x, permitiendo relacionar ambas gráficas de manera visual. La gráfica
corresponde a una ejecución sobre la plataforma Juno, para una
factorización de Cholesky sobre una matriz de tamaño 4608 elementos
dividida en bloques de tamaño 512 elementos.\\


\begin{figure}
  \centering
  \setlength{\fboxsep}{5pt}
  \fbox{\includegraphics[width=1\textwidth]{Figures/Politicas_evo/P3_4608-512.eps}}
  \caption[Escalado de frecuencia en función del número de tareas listas
  según la política P3]{Escalado de frecuencia en función del número de
    tareas listas según la política P3. La ejecución corresponde a una
    factorización de Cholesky sobre una matriz de 4608 elementos en
    precisión simple, dividida en bloques de tamaño de 512 elementos,
    ejecutada sobre la plataforma de desarrollo Juno (donde los cores big
    corresponden a cores ARM-A57).}
  \label{s5:fig:P3-evo}
\end{figure}


\comentario{Desarrollar más este párrafo}
Como se puede apreciar, en una primera fase que se desconoce el
tamaño máximo de la cola de tareas listas (ya que este está en constante
crecimiento/decrecimiento), la frecuencia varía al más mínimo cambio en el
tamaño. Una vez que el número de tareas listas alcanza el máximo y comienza
a decrementar, los cambios de frecuencia se realizan de manera escalonada
como se ha comentado en la sección anterior.






\subsection{P4}

\subsection{\ldots}


\section{Resultados experimentales}



%-- Configuraciones para emacs --
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "./principal.tex"
%%% End:
